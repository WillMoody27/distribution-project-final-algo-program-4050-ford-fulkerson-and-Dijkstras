
Student: William Hellems-Moody
Date: 12-1-23
Assignment: Distribution Project - Final Assignment [Updated 27 November]

Acknowledgment: Adam Abubakar

Data Representation (Required Section)

Regarding the data representation for this program, we were instructed to use the provided Supplier.java and Transporter.java classes to represent the suppliers and transporters. Focusing more on the Supplier class. This class is designed to model the nodes in the graph, which include fields such as the name, demand, inventory, storageCost, and maxCapacity. The purpose of this class was to provide a clear representation of manufacturers and distributors that each have their own storage and demand needs. The transporter class was provided to represent the transporters used along the routes/paths and essentially represent the edges between two suppliers. It also has its required fields, including source, destination, capacity, cost, allocation, from and to (to represent the beginning and ending point for each transporter). The role of this class is to outline and provide a detailed overview of the logistical edges within our graph representation.

CheapestPath

The cheapestPath method is used to locate the most cost-effective path for transporting goods between suppliers (nodes) and transporters (edges). This method utilizes multiple data structures such as maps, sets, and a custom private graph class to represent the distribution network of suppliers and transporters. The method begins by using a HashMap minCost to track the minimum cost to reach each supplier in the network. At the start of the implementation, every supplier is given a max possible value (Integer.MAX_VALUE) as their cost. This cost is dynamically updated as the algorithm uncovers the cheaper paths within the network. This method then employs the HashMap previousEdge. The previousEdge map assists the algorithm in reconstructing the cheapest path once reaching a destination, then tracking the best (cheapest) edge to reach each of the suppliers.

This method then employs a HashSet unvisitedSuppliers to track the unvisited suppliers within the network, ensuring that each supplier is considered only once. The primary structure used for this method is the Graph class, comprised of suppliers (nodes) and transporters (edges), used to represent the distribution network of suppliers and their linkage. The Path-Finding logic ensures the cost of the transporters is initialized and constructs the graph by including edges for each transporter. The method then incorporates a priority queue used in the determineCheapestPath method to set up a queue for the suppliers based on their current known minimum cost from a specified source. This allows the algorithm to determine which supplier to visit next in the queue efficiently.

AllocateForDemand

The allocateForDemand method also employs various data structures used to determine the maximum flow within the distribution network and assists with illustrating the relationships between suppliers (nodes) and transporters (edges). The method also employs a graph structure to represent the distribution network of suppliers, transporters, and the routes between them, which consists of fields like capacity (max amount to be transported) and cost (transporters cost per unit). A surplus HashMap surplusMap is also used to determine and store the surplus or demand for the suppliers. The surplus is found by subtracting the value of demand from the inventory of each supplier. 

The allocateForDemand method also implements a SuperSource and SuperSink, which act as a single aggregated source for all suppliers in the network. Likewise, the SuperSink serves as a single aggregated destination for all suppliers with demand, where both SuperSource and SuperSink represent the network flow start and end points within the network. This method also uses a priority queue and Set within the findAugPath method to implement a Breadth-First Search algorithm for finding the augmenting paths from the SuperSource to the SuperSink. In addition, a HashSet is used to track the visited suppliers. Like the cheapestPath method, the findAugPath method also makes use of the custom Graph and Edge structures, where the HashMap p_Map is used in the Graph class to record the paths taken during the BFS logic in the findAugPath method and is used in the reconstruction of the max flow path. Lastly, this method uses a List data structure for the updateResidual method, which is used for updating the flow along the path after each iteration of the Ford-Fulkerson algorithm and assists in returning the collection of transporters along the max flow path.

Algorithm Descriptions (Required Section - Brief Explanation)

Implementing the cheapestPath Method (using modified Dijkstras algorithm): 

The cheapest path method was implemented using a modified version of Dijkstras algorithm to find the least-cost path in a distribution network of suppliers represented within a directed graph. The method aims to return a collection of transporters, outlining the most cost-efficient path amongst suppliers. Initially, the algorithm assigns the max possible value (Integer.MAX_VALUE) as the cost to reach each supplier, excluding the starting point, which is set to zero. Next, the graph is then populated by adding edges representing transporters. Next, the algorithm iteratively updates the cost of reaching adjacent suppliers by considering the current transporters cost per unit, which is then updated until the destination node is reached. From here, the method backtracks from the destination supplier to the source and then uses the paths stored to determine the cheapest path between suppliers and transporters. This was accomplished through using a HashMap named minCost, which is used to track the minimum cost to reach each supplier constantly, and another “set” named unvisitedSuppliers to ensure that the algorithm can track which suppliers have been visited, ultimately leading to the cheapest path among suppliers being found.

?
Implementing the allocateForDemand method (using Ford-Fulkerson Algorithm)

I implemented the allocateForDemand method using the Ford-Fulkerson algorithm, which I decided was appropriate for determining the maximum flow within the distribution network. First, the method constructs a graph that will be used to represent my distribution flow network, consisting of suppliers (nodes) and transporters (edges). Starting with this approach allows me to focus on implementing the core functionality of the method, which is finding augmenting paths and adjusting the allocation of transporters within the network to satisfy demand where possible.

To incorporate the Ford-Fulkerson algorithm, several private helper methods, including findAugPath, updateResidual, and redistribSurp, were introduced in the SimpleAllocator. The findAugPath method represents a modified breadth-first search algorithm that iterates through the graph to identify paths where additional flow can ideally be sent. Once an augmented path is located, the updateResidual method is called to adjust the flows along this path, considering the capacity constraints and current flow within the network. Next, the goal of the private helper redistribSurp is to ensure and check if there is any remaining capacity in the network and redistribute surplus inventory. The process of updating the flow network of goods between suppliers and transporters halts when no more augmented paths are discovered in the network and when the entire demand of 1010 (for the test case provided by the instructor) is either satisfied or the max flow to satisfy a set of suppliers within the network is achieved. Afterward, the algorithm is set to return a collection of transporters allocated along that path, whose allocated amounts equal the influx of demand within the network, ensuring a balance between inflow and outflow. This ensures that the algorithm either fully satisfies the total demand within the network or maximizes the possible throughput given the constraints set along the distribution network by each supplier and transporter. 


Assessment of Correctness (Required Section)

This program implements two primary algorithms: cheapestPath and allocateForDemand. The cheapestPath method uses the modified Dijkstra algorithm to determine the least cost path between suppliers within a distribution network, considering factors like the cost and capacity constraints outlined for each transporter. This method returns the appropriate collection of transporters along the desired cheapest path in the network. This was tested against a graphical representation of a flow network consisting of two manufacturers, a depot, five distributors, nine transporters, a super source, and a super sink. This representation of a distribution network served as a way for me to test the given data and manually check the correct output of the cheapest path amongst my network of suppliers (distributors, manufacturers, and depots). In checking the output manually, I ensured that the received output of the program aligned with my manual checks across various scenarios and that the method for determining the cheapest path functioned properly. The modified Dijkstra algorithm correctly halts and displays a collection of transporters if a path is present (producing the correct output). Otherwise, the algorithm stops and simply returns an empty collection, illustrating either a path was unreachable or there was no given path, to begin with. 

The same applies to the allocateForDemand method implemented, which was also tested against this same graphical representation. The Ford-Fulkerson algorithm properly displays the correct allocation of transporters, which was also tested manually to ensure matching results. The algorithm showcased its ability to properly allocate the collection of transporters needed to fulfill the entire demand of the network. Through my analysis of the returned collection of the allocated transporters, I was assured that an augmented path was indeed found, and each of the transporters allocations was correctly adjusted by the updateResidual method, ensuring that all demand could be satisfied within my network. This form of testing showcased the ability of the method to allocate each transporter along the max flow path and satisfy most or all demand from a given source(s) to each of the predefined destinations, ensuring that the influx matched the outflow of units from the super source to the super sink. Likewise, it also terminates if no possible augmenting paths are present in the graph and returns an empty collection of transporters if a path is not found. 

Overall, after testing for the provided scenario, it was concluded that both functions operate as intended, where one determines the cheapest path by using the basic structure of Dijkstras algorithm, returning a collection of transporters along the cheapest path, and the other implements Ford-Fulkersons algorithm for determining the max flow along a network and generating a collection of allocated transporters within the flow network.

Reflection (Required Section - Less than 300 words as requested during lecture)

Reflecting on the program SimpleAllocator, this experience provided me with real-world experience using algorithms to manage a network of suppliers and transporters to find the least cost-effective paths and maximum network flow. Likewise, optimizing and allocating resources gave me a deeper understanding of graph theory and how it is used to solve complex logistical issues in a distribution network for a supply chain. In addition to learning more about flowgraphs in the logistical sense, I also found that the use of Ford-Fulkersons for optimizing the allocation of scooters along a path requires careful consideration of the method being applied and ensuring that the relationship between nodes was maintained and applied appropriately. I also found that the allocateForDemand method was very tedious and challenging, especially when dealing with a complex system such as a supply chain network that deals with product distribution.

A significant takeaway for me was the benefit of implementing a modified version of standard algorithms like Ford-Fulkerson and Dijkstras algorithm solely for the purpose of finding the cheapest path of a distribution network and allocating transporters to achieve a maximum flow in a given network. I found this algorithmic adaptation exercise quite valuable for gaining real-world experience on how algorithms learned in a class setting can be modified and used beyond their initial or standard implementation. Overall, this project underscored the significance of precise, rigorous testing and debugging and having an in-depth understanding of the algorithms you are using to achieve the desired overall outcome. Finally, working through this project, I feel that I have gained extremely valuable skills, regardless of the correctness of my program, that will undoubtedly benefit my future endeavors in computer science and software development beyond this course.
