
Student: William Hellems-Moody
Date: 12-1-23
Assignment: Distribution Project - Final Assignment [Updated 27 November]


Documentation.txt (Includes 4 Required Section): 

Data Representation (Required Section)

Regarding the data representation for this program, we were instructed to use the provided Supplier.java and Transporter.java classes to represent the suppliers and transporters. Focusing more on the Supplier class. This class is designed to model the nodes in the graph, which include fields such as the name, demand, inventory, and maxCapacity. The purpose of this class was to provide a clear representation of manufacturers and distributors that each have their own storage and demand needs. The transporter class was provided to represent the transporters used along the routes/paths and essentially represent the edges between two suppliers. It also has its required fields, including source, destination, capacity, cost, and allocation. The role of this class is to outline and provide a detailed overview of the logistical routes/paths within our graph representation.

I also decided to implement a graph class, which assisted in aiding me in representing and managing the network suppliers (nodes) and transporters (edges). This approach uses an adjacency list (i.e., Map<Supplier List<Edge>>) through the use of HashMaps to model the distribution network and the relationships between suppliers and transporters. Each supplier is represented as a node in the graph, and the connections (edges) are modeled as “Edge” objects. For this program, each Edge is represented by a transporter along the directed graph and contains information like the capacity, transportation cost, and the amount that can be transported between suppliers. This setup of my flow network allows me to efficiently implement my least-cost path algorithm (using Dijkstra’s), to look for the most cost-effective route between two suppliers, and the demand allocation algorithm (using Ford-Fulkerson), to optimize the distribution of resources across the network based on demand and capacity of the suppliers/distributors.

This design aimed to encapsulate the entire or, at the very least, most of the flow network within the graph object, representing a directed graph. This was necessary as using a directed graph significantly helped me map and visualize the flow of scooters (goods) from one supplier to another. Aside from this, this system, particularly in the implementation of the two primary methods allocateForDemand and CheapestPath, primarily makes use of data structures like HashMaps, Sets, Collections, and Priority Queues for tasks like processing nodes and checking the minimum cost of an edge along a path, backtracking, implementing breadth-first search, updating and allocating transporters along a particular path, tracking visited suppliers, and determining the lowest cost of a path, and allocating a collection of transporters along a max flow path with the incorporation of a superSource to a superSink. The combination and use cases of each data structure used for a particular task were vital in separating the logic needed to satisfy the overall requirements of the project (i.e., implementing cheapestPath and allocateForDemand). 



Algorithm Descriptions (Required Section - Brief Explanation)

Implementing the cheapestPath Method (using modified Dijkstra’s algorithm): 

The cheapest path method was implemented using a modified version of Dijkstra’s algorithm to find the least-cost path in a distribution network of suppliers represented within a directed graph. The method aims to return a collection of transporters, outlining the most cost-efficient path amongst suppliers. Initially, the algorithm assigns the max possible value (Integer.MAX_VALUE) as the cost to reach each supplier, excluding the starting point, which is set to zero. Next, the graph is then populated by adding edges representing transporters. Next, the algorithm iteratively updates the cost of reaching adjacent suppliers by considering the current transporter’s cost per unit, which is then updated until the destination node is reached. From here, the method backtracks from the destination supplier to the source and then uses the paths stored to determine the cheapest path between suppliers and transporters. This was accomplished through using a HashMap named minCost, which is used to constantly track the minimum cost to reach each supplier, and another “set” named unvisitedSuppliers to ensure that the algorithm can track which suppliers have been visited, ultimately leading to the cheapest path among suppliers being found.


Implementing the allocateForDemand method (using Ford-Fulkerson Algorithm)

I implemented the allocateForDemand method using the Ford-Fulkerson algorithm, which I decided was appropriate for determining the maximum flow within the distribution network. First, the method constructs a graph that will be used to represent my distribution flow network, consisting of suppliers (nodes) and transporters (edges). Starting with this approach allows me to focus on implementing the core functionality of the method, which is finding augmenting paths and adjusting the allocation of transporters within the network to satisfy demand where possible.

To incorporate the Ford-Fulkerson algorithm, several private helper methods, including findAugmentingPath, updateResidual, and redistribSurp, were introduced in the SimpleAllocator. The findAugmentingPath method represents a modified breadth-first search algorithm that iterates through the graph to identify paths where additional flow can ideally be sent. Once an augmented path is located, the updateResidual method is called to adjust the flows along this path, considering the capacity constraints and current flow within the network. Next, the goal of the private helper redistribSurp is to ensure and check if there is any remaining capacity in the network and redistribute surplus inventory. The process of updating the flow network of goods between suppliers and transporters halts when no more augmented paths are discovered in the network and when the entire demand of 1010 (for the test case provided by the instructor) is either satisfied or the max flow to satisfy a set of suppliers within the network is achieved. Afterward, the algorithm is set to return a collection of transporters allocated along that path, whose allocated amounts equal the influx of demand within the network, ensuring a balance between inflow and outflow. This ensures that the algorithm either fully satisfies the total demand within the network or maximizes the possible throughput given the constraints set along the distribution network by each supplier and transporter. 


Assessment of Correctness (Required Section)

This program implements two primary algorithms: cheapestPath and allocateForDemand. The cheapestPath method uses the modified Dijkstra algorithm to determine the least cost path between suppliers within the graphical representation, considering factors like the cost and capacity constraints outlined for each transporter. This method returns the appropriate collection of transporters along the desired cheapest path in the network. This was tested against fabricated data (graph provided by instructor) for each supplier and transporter within the graph, ensuring the algorithm consistently finds the least costly path for any given scenario. 

Regarding the allocateForDemand method implemented for this program, this method uses Ford-Fulkerson’s to determine the maximum network flow to satisfy the suppliers’ demand where possible. This method was tested alongside the cheapestPath, utilizing the same fabricated data. Using the same data allowed me to assess the algorithm’s capacity to ascertain the optimal flow within the network. The testing showcased the method’s ability to allocate transporters to establish a maximum from a given source to specified destinations. Likewise, I realize that further testing is needed, particularly with more diverse and complex data sets, which may expose additional insights and areas of improvement. 

Overall, after testing for the provided scenario, it was concluded that both functions operate as intended, where one determines the cheapest path by using the basic structure of Dijkstra’s and the other implements Ford-Fulkerson’s algorithm for determining the max flow along a network through its allocation of transporters within the network. 


Reflection (Required Section - Less than 300 words as requested during lecture)

Reflecting on the program SimpleAllocator, this experience provided me with real-world experience using algorithms to manage a network of suppliers and transporters to find the least cost-effective paths and maximum network flow. Likewise, optimizing and allocating resources gave me a deeper understanding of graph theory and how its used to solve complex logistical issues in distribution network for a supply chain. In addition to learning more about flowgraphs in the logistical sense, I also found that the use of Ford-Fulkerson’s for optimizing the allocation of scooters along a path requires careful consideration of the method being applied and ensuring that the relationship between nodes was maintained and applied appropriately. I also found that the allocateForDemand method was very tedious and challenging, especially when dealing with a complex system such as a supply chain network that deals with product distribution.

A significant takeaway for me was the benefit of implementing a modified version of standard algorithms like Ford-Fulkerson and Dijkstra’s algorithm solely for the purpose of finding the cheapest path of a distribution network and allocating transporters to achieve a maximum flow in a given network. I found this algorithmic adaptation exercise quite valuable for gaining real-world experience on how algorithms learned in a class setting can be modified and used beyond their initial or standard implementation. Overall, this project underscored the significance of precise, rigorous testing and debugging and having an in-depth understanding of the algorithms you are using to achieve the desired overall outcome. Finally, working through this project, I feel that I have gained extremely valuable skills, regardless of the correctness of my program, that will undoubtedly benefit my future endeavors in computer science and software development beyond this course.
